/* automatically generated by rust-bindgen */

pub const _FEATURES_H : u32 = 1;
pub const _DEFAULT_SOURCE : u32 = 1;
pub const __USE_ISOC11 : u32 = 1;
pub const __USE_ISOC99 : u32 = 1;
pub const __USE_ISOC95 : u32 = 1;
pub const __USE_POSIX_IMPLICITLY : u32 = 1;
pub const _POSIX_SOURCE : u32 = 1;
pub const _POSIX_C_SOURCE : u32 = 200809;
pub const __USE_POSIX : u32 = 1;
pub const __USE_POSIX2 : u32 = 1;
pub const __USE_POSIX199309 : u32 = 1;
pub const __USE_POSIX199506 : u32 = 1;
pub const __USE_XOPEN2K : u32 = 1;
pub const __USE_XOPEN2K8 : u32 = 1;
pub const _ATFILE_SOURCE : u32 = 1;
pub const __USE_MISC : u32 = 1;
pub const __USE_ATFILE : u32 = 1;
pub const __USE_FORTIFY_LEVEL : u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS : u32 = 0;
pub const _STDC_PREDEF_H : u32 = 1;
pub const __STDC_IEC_559__ : u32 = 1;
pub const __STDC_IEC_559_COMPLEX__ : u32 = 1;
pub const __STDC_ISO_10646__ : u32 = 201706;
pub const __STDC_NO_THREADS__ : u32 = 1;
pub const __GNU_LIBRARY__ : u32 = 6;
pub const __GLIBC__ : u32 = 2;
pub const __GLIBC_MINOR__ : u32 = 27;
pub const _SYS_CDEFS_H : u32 = 1;
pub const __glibc_c99_flexarr_available : u32 = 1;
pub const __WORDSIZE : u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1;
pub const __SYSCALL_WORDSIZE : u32 = 64;
pub const __HAVE_GENERIC_SELECTION : u32 = 1;
pub const __GLIBC_USE_LIB_EXT2 : u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT : u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT : u32 = 0;
pub const _STDLIB_H : u32 = 1;
pub const WNOHANG : u32 = 1;
pub const WUNTRACED : u32 = 2;
pub const WSTOPPED : u32 = 2;
pub const WEXITED : u32 = 4;
pub const WCONTINUED : u32 = 8;
pub const WNOWAIT : u32 = 16777216;
pub const __WNOTHREAD : u32 = 536870912;
pub const __WALL : u32 = 1073741824;
pub const __WCLONE : u32 = 2147483648;
pub const __ENUM_IDTYPE_T : u32 = 1;
pub const __W_CONTINUED : u32 = 65535;
pub const __WCOREFLAG : u32 = 128;
pub const __HAVE_FLOAT128 : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128 : u32 = 0;
pub const __HAVE_FLOAT64X : u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE : u32 = 1;
pub const __HAVE_FLOAT16 : u32 = 0;
pub const __HAVE_FLOAT32 : u32 = 1;
pub const __HAVE_FLOAT64 : u32 = 1;
pub const __HAVE_FLOAT32X : u32 = 1;
pub const __HAVE_FLOAT128X : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16 : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32 : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64 : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X : u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X : u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF : u32 = 0;
pub const __ldiv_t_defined : u32 = 1;
pub const __lldiv_t_defined : u32 = 1;
pub const RAND_MAX : u32 = 2147483647;
pub const EXIT_FAILURE : u32 = 1;
pub const EXIT_SUCCESS : u32 = 0;
pub const _SYS_TYPES_H : u32 = 1;
pub const _BITS_TYPES_H : u32 = 1;
pub const _BITS_TYPESIZES_H : u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T : u32 = 1;
pub const __INO_T_MATCHES_INO64_T : u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T : u32 = 1;
pub const __FD_SETSIZE : u32 = 1024;
pub const __clock_t_defined : u32 = 1;
pub const __clockid_t_defined : u32 = 1;
pub const __time_t_defined : u32 = 1;
pub const __timer_t_defined : u32 = 1;
pub const _BITS_STDINT_INTN_H : u32 = 1;
pub const __BIT_TYPES_DEFINED__ : u32 = 1;
pub const _ENDIAN_H : u32 = 1;
pub const __LITTLE_ENDIAN : u32 = 1234;
pub const __BIG_ENDIAN : u32 = 4321;
pub const __PDP_ENDIAN : u32 = 3412;
pub const __BYTE_ORDER : u32 = 1234;
pub const __FLOAT_WORD_ORDER : u32 = 1234;
pub const LITTLE_ENDIAN : u32 = 1234;
pub const BIG_ENDIAN : u32 = 4321;
pub const PDP_ENDIAN : u32 = 3412;
pub const BYTE_ORDER : u32 = 1234;
pub const _BITS_BYTESWAP_H : u32 = 1;
pub const _BITS_UINTN_IDENTITY_H : u32 = 1;
pub const _SYS_SELECT_H : u32 = 1;
pub const __FD_ZERO_STOS : & 'static [ u8;
6usize ] = b"stosq\0";
pub const __sigset_t_defined : u32 = 1;
pub const __timeval_defined : u32 = 1;
pub const __timespec_defined : u32 = 1;
pub const FD_SETSIZE : u32 = 1024;
pub const _SYS_SYSMACROS_H : u32 = 1;
pub const _BITS_SYSMACROS_H : u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H : u32 = 1;
pub const _THREAD_SHARED_TYPES_H : u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H : u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T : u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T : u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T : u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T : u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T : u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T : u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T : u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T : u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION : u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND : u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION : u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED : u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV : u32 = 1;
pub const __have_pthread_attr_t : u32 = 1;
pub const _ALLOCA_H : u32 = 1;
pub const MKL_DOMAIN_ALL : u32 = 0;
pub const MKL_DOMAIN_BLAS : u32 = 1;
pub const MKL_DOMAIN_FFT : u32 = 2;
pub const MKL_DOMAIN_VML : u32 = 3;
pub const MKL_DOMAIN_PARDISO : u32 = 4;
pub const MKL_CBWR_BRANCH : u32 = 1;
pub const MKL_CBWR_ALL : i32 = -1;
pub const MKL_CBWR_UNSET_ALL : u32 = 0;
pub const MKL_CBWR_OFF : u32 = 0;
pub const MKL_CBWR_BRANCH_OFF : u32 = 1;
pub const MKL_CBWR_AUTO : u32 = 2;
pub const MKL_CBWR_COMPATIBLE : u32 = 3;
pub const MKL_CBWR_SSE2 : u32 = 4;
pub const MKL_CBWR_SSSE3 : u32 = 6;
pub const MKL_CBWR_SSE4_1 : u32 = 7;
pub const MKL_CBWR_SSE4_2 : u32 = 8;
pub const MKL_CBWR_AVX : u32 = 9;
pub const MKL_CBWR_AVX2 : u32 = 10;
pub const MKL_CBWR_AVX512_MIC : u32 = 11;
pub const MKL_CBWR_AVX512 : u32 = 12;
pub const MKL_CBWR_AVX512_MIC_E1 : u32 = 13;
pub const MKL_CBWR_SUCCESS : u32 = 0;
pub const MKL_CBWR_ERR_INVALID_SETTINGS : i32 = -1;
pub const MKL_CBWR_ERR_INVALID_INPUT : i32 = -2;
pub const MKL_CBWR_ERR_UNSUPPORTED_BRANCH : i32 = -3;
pub const MKL_CBWR_ERR_UNKNOWN_BRANCH : i32 = -4;
pub const MKL_CBWR_ERR_MODE_CHANGE_FAILURE : i32 = -8;
pub const MKL_CBWR_SSE3 : u32 = 5;
pub const MKL_PEAK_MEM_DISABLE : u32 = 0;
pub const MKL_PEAK_MEM_ENABLE : u32 = 1;
pub const MKL_PEAK_MEM_RESET : i32 = -1;
pub const MKL_PEAK_MEM : u32 = 2;
pub const MKL_ENABLE_SSE4_2 : u32 = 0;
pub const MKL_ENABLE_AVX : u32 = 1;
pub const MKL_ENABLE_AVX2 : u32 = 2;
pub const MKL_ENABLE_AVX512_MIC : u32 = 3;
pub const MKL_ENABLE_AVX512 : u32 = 4;
pub const MKL_ENABLE_AVX512_MIC_E1 : u32 = 5;
pub const MKL_SINGLE_PATH_ENABLE : u32 = 1536;
pub const MKL_INTERFACE_LP64 : u32 = 0;
pub const MKL_INTERFACE_ILP64 : u32 = 1;
pub const MKL_INTERFACE_GNU : u32 = 2;
pub const MKL_THREADING_INTEL : u32 = 0;
pub const MKL_THREADING_SEQUENTIAL : u32 = 1;
pub const MKL_THREADING_PGI : u32 = 2;
pub const MKL_THREADING_GNU : u32 = 3;
pub const MKL_THREADING_TBB : u32 = 4;
pub const MKL_EXIT_UNSUPPORTED_CPU : u32 = 1;
pub const MKL_EXIT_CORRUPTED_INSTALL : u32 = 2;
pub const MKL_EXIT_NO_MEMORY : u32 = 3;
pub const MKL_MEM_MCDRAM : u32 = 1;
pub type wchar_t = :: std :: os :: raw :: c_int;
pub const idtype_t_P_ALL : idtype_t = 0;
pub const idtype_t_P_PID : idtype_t = 1;
pub const idtype_t_P_PGID : idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < div_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < div_t > ( ) ) ) . rem as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ) );
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ) );
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ) );
} extern "C" { pub fn __ctype_get_mb_cur_max ( ) -> usize;
} extern "C" { pub fn atof ( __nptr : * const :: std :: os :: raw :: c_char ) -> f64;
} extern "C" { pub fn atoi ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn atol ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn atoll ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_longlong;
} extern "C" { pub fn strtod ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64;
} extern "C" { pub fn strtof ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f32;
} extern "C" { pub fn strtold ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> u128;
} extern "C" { pub fn strtol ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn strtoul ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulong;
} extern "C" { pub fn strtoq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong;
} extern "C" { pub fn strtouq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong;
} extern "C" { pub fn strtoll ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong;
} extern "C" { pub fn strtoull ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong;
} extern "C" { pub fn l64a ( __n : :: std :: os :: raw :: c_long ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn a64l ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long;
} pub type __u_char = :: std :: os :: raw :: c_uchar;
pub type __u_short = :: std :: os :: raw :: c_ushort;
pub type __u_int = :: std :: os :: raw :: c_uint;
pub type __u_long = :: std :: os :: raw :: c_ulong;
pub type __int8_t = :: std :: os :: raw :: c_schar;
pub type __uint8_t = :: std :: os :: raw :: c_uchar;
pub type __int16_t = :: std :: os :: raw :: c_short;
pub type __uint16_t = :: std :: os :: raw :: c_ushort;
pub type __int32_t = :: std :: os :: raw :: c_int;
pub type __uint32_t = :: std :: os :: raw :: c_uint;
pub type __int64_t = :: std :: os :: raw :: c_long;
pub type __uint64_t = :: std :: os :: raw :: c_ulong;
pub type __quad_t = :: std :: os :: raw :: c_long;
pub type __u_quad_t = :: std :: os :: raw :: c_ulong;
pub type __intmax_t = :: std :: os :: raw :: c_long;
pub type __uintmax_t = :: std :: os :: raw :: c_ulong;
pub type __dev_t = :: std :: os :: raw :: c_ulong;
pub type __uid_t = :: std :: os :: raw :: c_uint;
pub type __gid_t = :: std :: os :: raw :: c_uint;
pub type __ino_t = :: std :: os :: raw :: c_ulong;
pub type __ino64_t = :: std :: os :: raw :: c_ulong;
pub type __mode_t = :: std :: os :: raw :: c_uint;
pub type __nlink_t = :: std :: os :: raw :: c_ulong;
pub type __off_t = :: std :: os :: raw :: c_long;
pub type __off64_t = :: std :: os :: raw :: c_long;
pub type __pid_t = :: std :: os :: raw :: c_int;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int;
2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __fsid_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) );
} pub type __clock_t = :: std :: os :: raw :: c_long;
pub type __rlim_t = :: std :: os :: raw :: c_ulong;
pub type __rlim64_t = :: std :: os :: raw :: c_ulong;
pub type __id_t = :: std :: os :: raw :: c_uint;
pub type __time_t = :: std :: os :: raw :: c_long;
pub type __useconds_t = :: std :: os :: raw :: c_uint;
pub type __suseconds_t = :: std :: os :: raw :: c_long;
pub type __daddr_t = :: std :: os :: raw :: c_int;
pub type __key_t = :: std :: os :: raw :: c_int;
pub type __clockid_t = :: std :: os :: raw :: c_int;
pub type __timer_t = * mut :: std :: os :: raw :: c_void;
pub type __blksize_t = :: std :: os :: raw :: c_long;
pub type __blkcnt_t = :: std :: os :: raw :: c_long;
pub type __blkcnt64_t = :: std :: os :: raw :: c_long;
pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong;
pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong;
pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong;
pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong;
pub type __fsword_t = :: std :: os :: raw :: c_long;
pub type __ssize_t = :: std :: os :: raw :: c_long;
pub type __syscall_slong_t = :: std :: os :: raw :: c_long;
pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = * mut :: std :: os :: raw :: c_char;
pub type __intptr_t = :: std :: os :: raw :: c_long;
pub type __socklen_t = :: std :: os :: raw :: c_uint;
pub type __sig_atomic_t = :: std :: os :: raw :: c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = :: std :: os :: raw :: c_ulong;
pub type ushort = :: std :: os :: raw :: c_ushort;
pub type uint = :: std :: os :: raw :: c_uint;
pub type u_int8_t = :: std :: os :: raw :: c_uchar;
pub type u_int16_t = :: std :: os :: raw :: c_ushort;
pub type u_int32_t = :: std :: os :: raw :: c_uint;
pub type u_int64_t = :: std :: os :: raw :: c_ulong;
pub type register_t = :: std :: os :: raw :: c_long;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong;
16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __sigset_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ) );
} pub type sigset_t = __sigset_t;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timeval > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timeval > ( ) ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) );
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) );
} pub type suseconds_t = __suseconds_t;
pub type __fd_mask = :: std :: os :: raw :: c_long;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask;
16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < fd_set > ( ) ) ) . __fds_bits as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( fd_set ) , "::" , stringify ! ( __fds_bits ) ) );
} pub type fd_mask = __fd_mask;
extern "C" { pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn gnu_dev_major ( __dev : __dev_t ) -> :: std :: os :: raw :: c_uint;
} extern "C" { pub fn gnu_dev_minor ( __dev : __dev_t ) -> :: std :: os :: raw :: c_uint;
} extern "C" { pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint ) -> __dev_t;
} pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar;
7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_rwlock_arch_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_rwlock_arch_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( __pthread_rwlock_arch_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_rwlock_arch_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_rwlock_arch_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __readers as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __readers ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __writers as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __wrphase_futex as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __wrphase_futex ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __writers_futex as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers_futex ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad3 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad3 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad4 as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad4 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __cur_writer as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __cur_writer ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __shared ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __rwelision ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad1 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad2 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __flags ) ) );
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) );
} pub type __pthread_list_t = __pthread_internal_list;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( __pthread_mutex_s ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __count ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __list ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ :: std :: os :: raw :: c_uint;
2usize ] , pub __g_size : [ :: std :: os :: raw :: c_uint;
2usize ] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [ :: std :: os :: raw :: c_uint;
2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : :: std :: os :: raw :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) );
} # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1 > ( ) ) ) . __wseq as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1 > ( ) ) ) . __wseq32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq32 ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : :: std :: os :: raw :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) );
} # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2 > ( ) ) ) . __g1_start as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2 > ( ) ) ) . __g1_start32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start32 ) ) );
} # [ test ] fn bindgen_test_layout___pthread_cond_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_refs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_refs ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_size as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g1_orig_size as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g1_orig_size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __wrefs as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __wrefs ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_signals as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_signals ) ) );
} pub type pthread_t = :: std :: os :: raw :: c_ulong;
# [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char;
4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char;
4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) );
} pub type pthread_key_t = :: std :: os :: raw :: c_uint;
pub type pthread_once_t = :: std :: os :: raw :: c_int;
# [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char;
56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64;
7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char;
40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64;
5usize ] , } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ :: std :: os :: raw :: c_char;
48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64;
6usize ] , } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [ :: std :: os :: raw :: c_char;
56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64;
7usize ] , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char;
8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) );
} pub type pthread_spinlock_t = :: std :: os :: raw :: c_int;
# [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char;
32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64;
4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) );
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char;
4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) );
} extern "C" { pub fn random ( ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn srandom ( __seed : :: std :: os :: raw :: c_uint );
} extern "C" { pub fn initstate ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn setstate ( __statebuf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [ test ] fn bindgen_test_layout_random_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < random_data > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( random_data ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < random_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( random_data ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . fptr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( fptr ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rptr ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . state as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( state ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rand_type as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_type ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rand_deg as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_deg ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rand_sep as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_sep ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . end_ptr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( end_ptr ) ) );
} extern "C" { pub fn random_r ( __buf : * mut random_data , __result : * mut i32 ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn srandom_r ( __seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn initstate_r ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn setstate_r ( __statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn rand ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn srand ( __seed : :: std :: os :: raw :: c_uint );
} extern "C" { pub fn rand_r ( __seed : * mut :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn drand48 ( ) -> f64;
} extern "C" { pub fn erand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> f64;
} extern "C" { pub fn lrand48 ( ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn nrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn mrand48 ( ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn jrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn srand48 ( __seedval : :: std :: os :: raw :: c_long );
} extern "C" { pub fn seed48 ( __seed16v : * mut :: std :: os :: raw :: c_ushort ) -> * mut :: std :: os :: raw :: c_ushort;
} extern "C" { pub fn lcong48 ( __param : * mut :: std :: os :: raw :: c_ushort );
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct drand48_data { pub __x : [ :: std :: os :: raw :: c_ushort;
3usize ] , pub __old_x : [ :: std :: os :: raw :: c_ushort;
3usize ] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_drand48_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < drand48_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( drand48_data ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < drand48_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( drand48_data ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __x as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __x ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __old_x as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __old_x ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __c as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __c ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __init as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __init ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __a as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __a ) ) );
} extern "C" { pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn erand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn nrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn jrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn srand48_r ( __seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn seed48_r ( __seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn lcong48_r ( __param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn malloc ( __size : :: std :: os :: raw :: c_ulong ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn calloc ( __nmemb : :: std :: os :: raw :: c_ulong , __size : :: std :: os :: raw :: c_ulong ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn realloc ( __ptr : * mut :: std :: os :: raw :: c_void , __size : :: std :: os :: raw :: c_ulong ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn free ( __ptr : * mut :: std :: os :: raw :: c_void );
} extern "C" { pub fn alloca ( __size : :: std :: os :: raw :: c_ulong ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn valloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn posix_memalign ( __memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn aligned_alloc ( __alignment : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn abort ( );
} extern "C" { pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void ) > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn exit ( __status : :: std :: os :: raw :: c_int );
} extern "C" { pub fn quick_exit ( __status : :: std :: os :: raw :: c_int );
} extern "C" { pub fn _Exit ( __status : :: std :: os :: raw :: c_int );
} extern "C" { pub fn getenv ( __name : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn putenv ( __string : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn setenv ( __name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn unsetenv ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn clearenv ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mktemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn mkstemp ( __template : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mkstemps ( __template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mkdtemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn system ( __command : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn realpath ( __name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int >;
extern "C" { pub fn bsearch ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn qsort ( __base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t );
} extern "C" { pub fn abs ( __x : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn labs ( __x : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_long;
} extern "C" { pub fn llabs ( __x : :: std :: os :: raw :: c_longlong ) -> :: std :: os :: raw :: c_longlong;
} extern "C" { pub fn div ( __numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int ) -> div_t;
} extern "C" { pub fn ldiv ( __numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long ) -> ldiv_t;
} extern "C" { pub fn lldiv ( __numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong ) -> lldiv_t;
} extern "C" { pub fn ecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn fcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn gcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn qecvt ( __value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn qfcvt ( __value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn qgcvt ( __value : u128 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char;
} extern "C" { pub fn ecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn fcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn qecvt_r ( __value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn qfcvt_r ( __value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mblen ( __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn wctomb ( __s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> usize;
} extern "C" { pub fn wcstombs ( __s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize ) -> usize;
} extern "C" { pub fn rpmatch ( __response : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn getsubopt ( __optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * mut :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn getloadavg ( __loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _MKL_Complex8 { pub real : f32 , pub imag : f32 , } # [ test ] fn bindgen_test_layout__MKL_Complex8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _MKL_Complex8 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( _MKL_Complex8 ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < _MKL_Complex8 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _MKL_Complex8 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKL_Complex8 > ( ) ) ) . real as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _MKL_Complex8 ) , "::" , stringify ! ( real ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKL_Complex8 > ( ) ) ) . imag as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( _MKL_Complex8 ) , "::" , stringify ! ( imag ) ) );
} pub type MKL_Complex8 = _MKL_Complex8;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _MKL_Complex16 { pub real : f64 , pub imag : f64 , } # [ test ] fn bindgen_test_layout__MKL_Complex16 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _MKL_Complex16 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _MKL_Complex16 ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < _MKL_Complex16 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _MKL_Complex16 ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKL_Complex16 > ( ) ) ) . real as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _MKL_Complex16 ) , "::" , stringify ! ( real ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKL_Complex16 > ( ) ) ) . imag as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _MKL_Complex16 ) , "::" , stringify ! ( imag ) ) );
} pub type MKL_Complex16 = _MKL_Complex16;
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MKLVersion { pub MajorVersion : :: std :: os :: raw :: c_int , pub MinorVersion : :: std :: os :: raw :: c_int , pub UpdateVersion : :: std :: os :: raw :: c_int , pub ProductStatus : * mut :: std :: os :: raw :: c_char , pub Build : * mut :: std :: os :: raw :: c_char , pub Processor : * mut :: std :: os :: raw :: c_char , pub Platform : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_MKLVersion ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MKLVersion > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( MKLVersion ) ) );
assert_eq ! ( :: std :: mem :: align_of :: < MKLVersion > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MKLVersion ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . MajorVersion as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( MajorVersion ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . MinorVersion as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( MinorVersion ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . UpdateVersion as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( UpdateVersion ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . ProductStatus as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( ProductStatus ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . Build as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( Build ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . Processor as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( Processor ) ) );
assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MKLVersion > ( ) ) ) . Platform as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( MKLVersion ) , "::" , stringify ! ( Platform ) ) );
} pub const MKL_LAYOUT_MKL_ROW_MAJOR : MKL_LAYOUT = 101;
pub const MKL_LAYOUT_MKL_COL_MAJOR : MKL_LAYOUT = 102;
pub type MKL_LAYOUT = u32;
pub const MKL_TRANSPOSE_MKL_NOTRANS : MKL_TRANSPOSE = 111;
pub const MKL_TRANSPOSE_MKL_TRANS : MKL_TRANSPOSE = 112;
pub const MKL_TRANSPOSE_MKL_CONJTRANS : MKL_TRANSPOSE = 113;
pub type MKL_TRANSPOSE = u32;
pub const MKL_UPLO_MKL_UPPER : MKL_UPLO = 121;
pub const MKL_UPLO_MKL_LOWER : MKL_UPLO = 122;
pub type MKL_UPLO = u32;
pub const MKL_DIAG_MKL_NONUNIT : MKL_DIAG = 131;
pub const MKL_DIAG_MKL_UNIT : MKL_DIAG = 132;
pub type MKL_DIAG = u32;
pub const MKL_SIDE_MKL_LEFT : MKL_SIDE = 141;
pub const MKL_SIDE_MKL_RIGHT : MKL_SIDE = 142;
pub type MKL_SIDE = u32;
pub const MKL_COMPACT_PACK_MKL_COMPACT_SSE : MKL_COMPACT_PACK = 181;
pub const MKL_COMPACT_PACK_MKL_COMPACT_AVX : MKL_COMPACT_PACK = 182;
pub const MKL_COMPACT_PACK_MKL_COMPACT_AVX512 : MKL_COMPACT_PACK = 183;
pub type MKL_COMPACT_PACK = u32;
extern "C" { pub fn MKL_Get_Version ( ver : * mut MKLVersion );
} extern "C" { pub fn MKL_Get_Version_String ( buffer : * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int );
} extern "C" { pub fn MKL_Free_Buffers ( );
} extern "C" { pub fn MKL_Thread_Free_Buffers ( );
} extern "C" { pub fn MKL_Mem_Stat ( nbuffers : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong;
} extern "C" { pub fn MKL_Peak_Mem_Usage ( reset : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong;
} extern "C" { pub fn MKL_malloc ( size : usize , align : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn MKL_calloc ( num : usize , size : usize , align : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn MKL_realloc ( ptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> * mut :: std :: os :: raw :: c_void;
} extern "C" { pub fn MKL_free ( ptr : * mut :: std :: os :: raw :: c_void );
} extern "C" { pub fn MKL_Disable_Fast_MM ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Get_Cpu_Clocks ( arg1 : * mut :: std :: os :: raw :: c_ulonglong );
} extern "C" { pub fn MKL_Get_Cpu_Frequency ( ) -> f64;
} extern "C" { pub fn MKL_Get_Max_Cpu_Frequency ( ) -> f64;
} extern "C" { pub fn MKL_Get_Clocks_Frequency ( ) -> f64;
} extern "C" { pub fn MKL_Set_Num_Threads_Local ( nth : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Num_Threads ( nth : :: std :: os :: raw :: c_int );
} extern "C" { pub fn MKL_Get_Max_Threads ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Num_Stripes ( nstripes : :: std :: os :: raw :: c_int );
} extern "C" { pub fn MKL_Get_Num_Stripes ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Domain_Set_Num_Threads ( nth : :: std :: os :: raw :: c_int , MKL_DOMAIN : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Domain_Get_Max_Threads ( MKL_DOMAIN : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Dynamic ( bool_MKL_DYNAMIC : :: std :: os :: raw :: c_int );
} extern "C" { pub fn MKL_Get_Dynamic ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_PROGRESS ( thread : * mut :: std :: os :: raw :: c_int , step : * mut :: std :: os :: raw :: c_int , stage : * mut :: std :: os :: raw :: c_char , lstage : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_PROGRESS_ ( thread : * mut :: std :: os :: raw :: c_int , step : * mut :: std :: os :: raw :: c_int , stage : * mut :: std :: os :: raw :: c_char , lstage : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mkl_progress ( thread : * mut :: std :: os :: raw :: c_int , step : * mut :: std :: os :: raw :: c_int , stage : * mut :: std :: os :: raw :: c_char , lstage : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn mkl_progress_ ( thread : * mut :: std :: os :: raw :: c_int , step : * mut :: std :: os :: raw :: c_int , stage : * mut :: std :: os :: raw :: c_char , lstage : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Enable_Instructions ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Interface_Layer ( code : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Threading_Layer ( code : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} pub type XerblaEntry = :: std :: option :: Option < unsafe extern "C" fn ( Name : * const :: std :: os :: raw :: c_char , Num : * const :: std :: os :: raw :: c_int , Len : :: std :: os :: raw :: c_int ) >;
extern "C" { pub fn mkl_set_xerbla ( xerbla : XerblaEntry ) -> XerblaEntry;
} pub type ProgressEntry = :: std :: option :: Option < unsafe extern "C" fn ( thread : * mut :: std :: os :: raw :: c_int , step : * mut :: std :: os :: raw :: c_int , stage : * mut :: std :: os :: raw :: c_char , stage_len : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int >;
extern "C" { pub fn mkl_set_progress ( progress : ProgressEntry ) -> ProgressEntry;
} pub type PardisopivotEntry = :: std :: option :: Option < unsafe extern "C" fn ( aii : * mut f64 , bii : * mut f64 , eps : * mut f64 ) -> :: std :: os :: raw :: c_int >;
extern "C" { pub fn mkl_set_pardiso_pivot ( pardiso_pivot : PardisopivotEntry ) -> PardisopivotEntry;
} extern "C" { pub fn MKL_CBWR_Get ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_CBWR_Set ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_CBWR_Get_Auto_Branch ( ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Env_Mode ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Verbose ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int;
} pub type MKLExitHandler = :: std :: option :: Option < unsafe extern "C" fn ( why : :: std :: os :: raw :: c_int ) >;
extern "C" { pub fn MKL_Set_Exit_Handler ( h : MKLExitHandler );
} pub const MKL_BLACS_CUSTOM : _bindgen_ty_1 = 0;
pub const MKL_BLACS_MSMPI : _bindgen_ty_1 = 1;
pub const MKL_BLACS_INTELMPI : _bindgen_ty_1 = 2;
pub const MKL_BLACS_MPICH2 : _bindgen_ty_1 = 3;
pub const MKL_BLACS_LASTMPI : _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = u32;
extern "C" { pub fn MKL_Set_mpi ( vendor : :: std :: os :: raw :: c_int , custom_library_name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Set_Memory_Limit ( mem_type : :: std :: os :: raw :: c_int , limit : usize ) -> :: std :: os :: raw :: c_int;
} extern "C" { pub fn MKL_Finalize ( );
}